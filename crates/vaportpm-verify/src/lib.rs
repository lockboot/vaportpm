// SPDX-License-Identifier: MIT OR Apache-2.0

//! Attestation verification for TPM and Nitro attestations
//!
//! This crate provides verification of attestation documents generated by vaportpm_attest:
//! - TPM attestation verification with EK public key matching
//! - X.509 certificate chain validation
//! - AWS Nitro COSE Sign1 document verification
//! - GCP Shielded VM AK certificate verification
//! - Root certificate public key hash extraction (SHA-256, hex-encoded)

mod error;
mod gcp;
mod nitro;
mod tpm;
mod x509;

use std::collections::BTreeMap;

use serde::Serialize;

// Re-export error type
pub use error::VerifyError;

// Re-export TPM types and functions (only those used by verification paths)
pub use tpm::{parse_quote_attest, verify_ecdsa_p256, TpmQuoteInfo};

// Re-export from vaportpm_attest
pub use vaportpm_attest::TpmAlg;

// Re-export Nitro types and functions
pub use nitro::{verify_nitro_attestation, NitroDocument, NitroVerifyResult};

// Re-export X.509 utility functions
pub use x509::{
    extract_public_key, hash_public_key, parse_and_validate_tpm_cert_chain, parse_cert_chain_pem,
    validate_tpm_cert_chain, ChainValidationResult, MAX_CHAIN_DEPTH,
};

// Re-export time type for testing
pub use pki_types::UnixTime;

/// Cloud provider identification
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize)]
pub enum CloudProvider {
    /// Amazon Web Services (Nitro TPM)
    Aws,
    /// Google Cloud Platform (Shielded VM)
    Gcp,
}

/// Known root CA certificates and public key hashes for cloud providers
///
/// Certificates are embedded from vaportpm_attest. Hashes are derived from
/// the certificate data at runtime, not hardcoded separately.
pub mod roots {
    use super::CloudProvider;
    use crate::x509::{extract_public_key, hash_public_key, parse_cert_chain_pem};
    use std::sync::OnceLock;

    // Re-export embedded root certificate PEMs from vaportpm_attest
    // Note: Intermediates are project-specific and must be fetched by the attestor
    pub use vaportpm_attest::roots::{AWS_NITRO_ROOT_PEM, GCP_EKAK_ROOT_PEM};

    // Re-export SKI/AKI lookup
    pub use vaportpm_attest::roots::find_issuer_by_aki;

    /// Cached root public key hashes (computed on first access)
    static ROOT_HASHES: OnceLock<RootHashes> = OnceLock::new();

    struct RootHashes {
        aws_nitro: String,
        gcp_ekak_amd: String,
    }

    fn compute_root_hashes() -> RootHashes {
        let aws_hash = compute_pubkey_hash(AWS_NITRO_ROOT_PEM).unwrap_or_default();
        let gcp_amd_hash = compute_pubkey_hash(GCP_EKAK_ROOT_PEM).unwrap_or_default();

        RootHashes {
            aws_nitro: aws_hash,
            gcp_ekak_amd: gcp_amd_hash,
        }
    }

    fn compute_pubkey_hash(pem: &str) -> Option<String> {
        let certs = parse_cert_chain_pem(pem).ok()?;
        let cert = certs.first()?;
        let pubkey = extract_public_key(cert).ok()?;
        Some(hash_public_key(&pubkey))
    }

    fn get_hashes() -> &'static RootHashes {
        ROOT_HASHES.get_or_init(compute_root_hashes)
    }

    /// AWS Nitro Enclave Root CA public key hash (SHA-256)
    ///
    /// Derived from the embedded AWS Nitro root certificate.
    pub fn aws_nitro_root_hash() -> &'static str {
        &get_hashes().aws_nitro
    }

    /// GCP Shielded VM EK/AK Root CA public key hash (SHA-256) - AMD/SEV
    ///
    /// Derived from the embedded GCP EK/AK root certificate for AMD instances.
    pub fn gcp_ekak_root_amd_hash() -> &'static str {
        &get_hashes().gcp_ekak_amd
    }

    /// Look up cloud provider from root public key hash
    ///
    /// Returns `Some(CloudProvider)` if the hash matches a known root CA,
    /// or `None` if the root is not recognized.
    pub fn provider_from_hash(hash: &str) -> Option<CloudProvider> {
        let hashes = get_hashes();
        if hash == hashes.aws_nitro {
            Some(CloudProvider::Aws)
        } else if hash == hashes.gcp_ekak_amd {
            Some(CloudProvider::Gcp)
        } else {
            None
        }
    }

    /// Check if a public key hash matches a known trust anchor
    pub fn is_known_root_hash(hash: &str) -> bool {
        provider_from_hash(hash).is_some()
    }
}

// Re-export types from vaportpm_attest for convenience
pub use vaportpm_attest::a9n::{
    AttestationContainer, AttestationData, AttestationOutput, EccPublicKeyCoords,
    GcpAttestationData, NitroAttestationData,
};

/// Result of successful attestation verification
#[derive(Debug, Serialize)]
pub struct VerificationResult {
    /// The nonce that was verified (hex-encoded)
    pub nonce: String,
    /// Cloud provider that issued the attestation
    pub provider: CloudProvider,
    /// PCR values from the attestation (index -> hex-encoded digest)
    pub pcrs: BTreeMap<u8, String>,
    /// SHA-256 hash of the root CA's public key
    pub root_pubkey_hash: String,
}

/// Verify an entire AttestationOutput
///
/// Supports two verification paths, both using TPM2_Quote:
///
/// 1. **GCP path**: If GCP attestation is present, verify the AK certificate
///    chain to Google's root CA, then verify the TPM2_Quote signature. PCR
///    values are verified against the Quote's PCR digest.
///
/// 2. **Nitro path** (AWS): If Nitro attestation is present, verify it and trust
///    the TPM signing key via the Nitro document's `public_key` binding. The
///    TPM2_Quote is verified for PCR values.
///
/// # Arguments
/// * `output` - The attestation output to verify
/// * `time` - Time to use for certificate validation (use `UnixTime::now()` for production)
///
/// # Returns
/// A unified `VerificationResult` containing:
/// - `nonce`: The verified challenge (from TPM2_Quote.extraData)
/// - `provider`: Cloud provider (AWS/GCP) if root CA is recognized
/// - `pcrs`: PCR values from the attestation
/// - `root_pubkey_hash`: SHA-256 of the trust anchor's public key
/// - `method`: How verification was performed
///
/// # Errors
/// Returns `NoValidAttestation` if no supported verification path is available.
pub fn verify_attestation_output(
    output: &AttestationOutput,
    time: UnixTime,
) -> Result<VerificationResult, VerifyError> {
    // Must have at least one TPM attestation
    if output.attestation.tpm.is_empty() {
        return Err(VerifyError::NoValidAttestation(
            "no TPM attestations present".into(),
        ));
    }

    // Try GCP verification path (certificate-based trust)
    if let Some(ref gcp_data) = output.attestation.gcp {
        return gcp::verify_gcp_attestation(output, gcp_data, time);
    }

    // Try Nitro verification path (Nitro NSM document-based trust)
    if let Some(ref nitro) = output.attestation.nitro {
        return verify_nitro_quote_attestation(output, nitro, time);
    }

    // No supported attestation method found
    Err(VerifyError::NoValidAttestation(
        "No GCP or Nitro attestation present. \
         Supported verification paths: AWS Nitro, GCP Shielded VM."
            .into(),
    ))
}

/// Verify Nitro attestation path using TPM2_Quote
///
/// This verification path:
/// 1. Parses TPM2_Quote attestation to extract PCR digest and nonce
/// 2. Verifies Quote signature with AK public key
/// 3. Verifies Nitro NSM document binds the AK public key
/// 4. Verifies PCRs match signed values in Nitro document
fn verify_nitro_quote_attestation(
    output: &AttestationOutput,
    nitro: &NitroAttestationData,
    time: UnixTime,
) -> Result<VerificationResult, VerifyError> {
    // Get the first (and typically only) TPM attestation
    let (key_type, attestation) = output.attestation.tpm.iter().next().unwrap();

    // Get the corresponding signing key (AK) public key
    let ak_pk = output.ak_pubkeys.get(key_type).ok_or_else(|| {
        VerifyError::NoValidAttestation(format!("{}: missing AK public key", key_type))
    })?;

    // Decode AK public key
    let ak_x = hex::decode(&ak_pk.x)?;
    let ak_y = hex::decode(&ak_pk.y)?;

    // Parse TPM2_Quote attestation
    let attest_data = hex::decode(&attestation.attest_data)?;
    let quote_info = parse_quote_attest(&attest_data)?;

    // Verify top-level nonce matches nonce in Quote (prevents tampering)
    let nonce_from_field = hex::decode(&output.nonce)?;
    if nonce_from_field != quote_info.nonce {
        return Err(VerifyError::InvalidAttest(format!(
            "Nonce field does not match nonce in Quote. \
             Field: {}, Quote: {}",
            output.nonce,
            hex::encode(&quote_info.nonce)
        )));
    }

    // Verify AK signature over TPM2_Quote
    let signature = hex::decode(&attestation.signature)?;
    let mut ak_pubkey = vec![0x04];
    ak_pubkey.extend(&ak_x);
    ak_pubkey.extend(&ak_y);
    verify_ecdsa_p256(&attest_data, &signature, &ak_pubkey)?;

    // Verify Nitro attestation (COSE signature, cert chain)
    let nitro_result = verify_nitro_attestation(
        &nitro.document,
        None, // Nonce validation happens via TPM binding below
        None, // Pubkey validation happens below
        time,
    )?;

    // Extract signed values from Nitro document
    let signed_pubkey = nitro_result.document.public_key.as_ref().ok_or_else(|| {
        VerifyError::NoValidAttestation(
            "Nitro document missing public_key field - cannot bind TPM signing key".into(),
        )
    })?;
    let signed_nonce = nitro_result.document.nonce.as_ref().ok_or_else(|| {
        VerifyError::NoValidAttestation(
            "Nitro document missing nonce field - cannot verify freshness".into(),
        )
    })?;

    // Verify the AK public key matches the signed public_key in NSM document
    let ak_secg = format!("04{}{}", ak_pk.x, ak_pk.y);
    if ak_secg != *signed_pubkey {
        return Err(VerifyError::SignatureInvalid(format!(
            "TPM signing key does not match Nitro public_key binding: {} != {}",
            ak_secg, signed_pubkey
        )));
    }

    // Verify TPM nonce matches Nitro nonce (proves attestations generated together)
    let tpm_nonce_hex = hex::encode(&quote_info.nonce);
    if tpm_nonce_hex != *signed_nonce {
        return Err(VerifyError::SignatureInvalid(format!(
            "TPM nonce does not match Nitro nonce - attestations not generated together: {} != {}",
            tpm_nonce_hex, signed_nonce
        )));
    }

    // Verify SHA-384 PCRs match signed values in Nitro document
    // The Nitro document contains nitrotpm_pcrs which are signed by AWS hardware
    let sha384_pcrs = output.pcrs.get("sha384").ok_or_else(|| {
        VerifyError::InvalidAttest("Missing SHA-384 PCRs - required for Nitro attestation".into())
    })?;

    let signed_pcrs = &nitro_result.document.pcrs;
    if signed_pcrs.is_empty() {
        return Err(VerifyError::InvalidAttest(
            "Nitro document contains no signed PCRs".into(),
        ));
    }

    // All signed PCRs must be present and match
    for (idx, signed_value) in signed_pcrs.iter() {
        match sha384_pcrs.get(idx) {
            Some(claimed_value) if claimed_value == signed_value => {
                // Match - good
            }
            Some(claimed_value) => {
                return Err(VerifyError::SignatureInvalid(format!(
                    "PCR {} SHA-384 mismatch: claimed {} != signed {}",
                    idx, claimed_value, signed_value
                )));
            }
            None => {
                return Err(VerifyError::SignatureInvalid(format!(
                    "PCR {} in signed Nitro document but missing from attestation",
                    idx
                )));
            }
        }
    }

    // Verify root is the known AWS Nitro root - fail if not recognized
    let provider = roots::provider_from_hash(&nitro_result.root_pubkey_hash).ok_or_else(|| {
        VerifyError::ChainValidation(format!(
            "Unknown root CA: {}. Only known cloud provider roots are trusted.",
            nitro_result.root_pubkey_hash
        ))
    })?;

    // Collect PCRs from the attestation (use SHA-384 for Nitro)
    let pcrs = output.pcrs.get("sha384").cloned().unwrap_or_default();

    // Nonce is from TPM2_Quote.extraData
    Ok(VerificationResult {
        nonce: hex::encode(&quote_info.nonce),
        provider,
        pcrs,
        root_pubkey_hash: nitro_result.root_pubkey_hash,
    })
}

/// Convenience function to verify attestation from JSON string
///
/// Parses JSON and calls `verify_attestation_output` with current time.
/// For testing with fixtures that have expired certificates, use
/// `verify_attestation_output` directly with a specific time.
pub fn verify_attestation_json(json: &str) -> Result<VerificationResult, VerifyError> {
    let output: AttestationOutput = serde_json::from_str(json)
        .map_err(|e| VerifyError::InvalidAttest(format!("JSON parse error: {}", e)))?;
    verify_attestation_output(&output, UnixTime::now())
}

#[cfg(test)]
mod tests {
    use super::*;

    // Timestamp for Nitro test fixture (Feb 3, 2026 11:00:00 UTC - within cert validity window)
    const NITRO_FIXTURE_TIMESTAMP_SECS: u64 = 1770116400;

    // Timestamp for GCP test fixture (Feb 2, 2026 when certificates are valid)
    const GCP_FIXTURE_TIMESTAMP_SECS: u64 = 1770019200; // Feb 2, 2026 08:00:00 UTC

    fn nitro_fixture_time() -> UnixTime {
        UnixTime::since_unix_epoch(std::time::Duration::from_secs(NITRO_FIXTURE_TIMESTAMP_SECS))
    }

    fn gcp_fixture_time() -> UnixTime {
        UnixTime::since_unix_epoch(std::time::Duration::from_secs(GCP_FIXTURE_TIMESTAMP_SECS))
    }

    #[test]
    fn test_verify_nitro_fixture() {
        let fixture = include_str!("../test-nitro-fixture.json");
        let output: AttestationOutput =
            serde_json::from_str(fixture).expect("Failed to parse test-nitro-fixture.json");

        let result = verify_attestation_output(&output, nitro_fixture_time())
            .expect("Verification should succeed");

        // Should be AWS (Nitro)
        assert_eq!(result.provider, CloudProvider::Aws);

        // Nonce is now from TPM2B_ATTEST.extraData, not the raw attest_data field
        assert!(!result.nonce.is_empty());

        // Should have a root pubkey hash (AWS Nitro root)
        assert!(!result.root_pubkey_hash.is_empty());
        assert_eq!(result.root_pubkey_hash.len(), 64); // SHA-256 = 32 bytes = 64 hex chars
    }

    #[test]
    fn test_verify_gcp_amd_fixture() {
        let fixture = include_str!("../test-gcp-amd-fixture.json");
        let output: AttestationOutput =
            serde_json::from_str(fixture).expect("Failed to parse test-gcp-fixture.json");

        let result = verify_attestation_output(&output, gcp_fixture_time())
            .expect("Verification should succeed");

        // Should be GCP
        assert_eq!(result.provider, CloudProvider::Gcp);

        // Should have the nonce from the Quote
        assert!(!result.nonce.is_empty());
        assert_eq!(
            result.nonce,
            "8a543108a653b4a1162232744cc9b945017a449dea4fbb0ca62f42d3ef145562"
        );

        // Should have PCR values
        assert!(!result.pcrs.is_empty());

        // Should have GCP root pubkey hash
        assert!(!result.root_pubkey_hash.is_empty());
        assert_eq!(result.root_pubkey_hash.len(), 64);
    }

    #[test]
    fn test_reject_empty_attestation() {
        let output = AttestationOutput {
            nonce: "deadbeef".to_string(),
            pcrs: std::collections::HashMap::new(),
            ak_pubkeys: std::collections::HashMap::new(),
            attestation: AttestationContainer {
                tpm: std::collections::HashMap::new(),
                nitro: None,
                gcp: None,
            },
        };

        let result = verify_attestation_output(&output, UnixTime::now());
        assert!(matches!(result, Err(VerifyError::NoValidAttestation(_))));
    }

    /// Test that tampering with the AK public key field is detected
    #[test]
    fn test_reject_tampered_nitro_public_key() {
        let fixture = include_str!("../test-nitro-fixture.json");
        let mut output: AttestationOutput =
            serde_json::from_str(fixture).expect("Failed to parse test-nitro-fixture.json");

        // Tamper with the AK public key (attacker tries to substitute their own key)
        // This should fail because it won't match the signed value in Nitro document
        output.ak_pubkeys.insert(
            "ecc_p256".to_string(),
            EccPublicKeyCoords {
                x: "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa".to_string(),
                y: "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb".to_string(),
            },
        );

        let result = verify_attestation_output(&output, nitro_fixture_time());
        assert!(
            matches!(result, Err(VerifyError::SignatureInvalid(_))),
            "Should reject tampered public_key field, got: {:?}",
            result
        );
    }

    /// Test that tampering with the top-level nonce field is detected
    #[test]
    fn test_reject_tampered_nitro_nonce() {
        let fixture = include_str!("../test-nitro-fixture.json");
        let mut output: AttestationOutput =
            serde_json::from_str(fixture).expect("Failed to parse test-nitro-fixture.json");

        // Tamper with the top-level nonce
        output.nonce = "deadbeef".to_string();

        let result = verify_attestation_output(&output, nitro_fixture_time());
        assert!(
            matches!(result, Err(VerifyError::InvalidAttest(_))),
            "Should reject tampered nonce field, got: {:?}",
            result
        );
    }

    /// Test that tampering with SHA-384 PCR values is detected
    #[test]
    fn test_reject_tampered_pcr_values() {
        let fixture = include_str!("../test-nitro-fixture.json");
        let mut output: AttestationOutput =
            serde_json::from_str(fixture).expect("Failed to parse test-nitro-fixture.json");

        // Tamper with a SHA-384 PCR value
        if let Some(sha384_pcrs) = output.pcrs.get_mut("sha384") {
            sha384_pcrs.insert(
                0,
                "deadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef".to_string()
            );
        }

        let result = verify_attestation_output(&output, nitro_fixture_time());
        // Tampering is detected: claimed PCR values don't match signed values in Nitro document
        assert!(
            matches!(result, Err(VerifyError::SignatureInvalid(_))),
            "Should reject tampered PCR values, got: {:?}",
            result
        );
    }
}

#[cfg(test)]
mod tdx_tests {
    use super::*;

    // Timestamp for GCP TDX test fixture (Feb 3, 2026 when certificates are valid)
    const GCP_TDX_FIXTURE_TIMESTAMP_SECS: u64 = 1770091200; // Feb 3, 2026 08:00:00 UTC

    fn gcp_tdx_fixture_time() -> UnixTime {
        UnixTime::since_unix_epoch(std::time::Duration::from_secs(
            GCP_TDX_FIXTURE_TIMESTAMP_SECS,
        ))
    }

    #[test]
    fn test_verify_gcp_tdx_fixture() {
        let fixture = include_str!("../test-gcp-tdx-fixture.json");
        let output: AttestationOutput =
            serde_json::from_str(fixture).expect("Failed to parse test-gcp-tdx-fixture.json");

        let result = verify_attestation_output(&output, gcp_tdx_fixture_time())
            .expect("Verification should succeed");

        // Should be GCP
        assert_eq!(result.provider, CloudProvider::Gcp);

        // Should have the nonce from the Quote
        assert_eq!(
            result.nonce,
            "6424632e79ec068f2189adf46d121b9a10f758c45a18c52f630da14600d4317b"
        );

        // Should have PCR values
        assert!(!result.pcrs.is_empty());

        // Root pubkey hash should match the known GCP root (same as AMD)
        assert_eq!(result.root_pubkey_hash.len(), 64);
    }
}
