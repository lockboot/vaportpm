// SPDX-License-Identifier: MIT OR Apache-2.0

//! Attestation verification for TPM and Nitro attestations
//!
//! This crate provides verification of attestation documents generated by vaportpm_attest:
//! - TPM attestation verification with EK public key matching
//! - X.509 certificate chain validation
//! - AWS Nitro COSE Sign1 document verification
//! - Root certificate public key hash extraction (SHA-256, hex-encoded)

mod error;
mod nitro;
mod tpm;
mod x509;

use serde::Serialize;

// Re-export error type
pub use error::VerifyError;

// Re-export TPM types and functions
pub use tpm::{
    calculate_pcr_policy, parse_tpm2b_attest, verify_ecdsa_p256, verify_pcr_policy,
    verify_tpm_attestation, verify_tpm_signature_only, TpmAttestInfo,
};

// Re-export from vaportpm_attest (single source of truth for TPM crypto)
pub use vaportpm_attest::{compute_ecc_p256_name, TpmAlg};

// Re-export Nitro types and functions
pub use nitro::{verify_nitro_attestation, NitroDocument, NitroVerifyResult};

// Re-export X.509 utility functions
pub use x509::{
    extract_public_key, hash_public_key, parse_and_validate_cert_chain,
    parse_and_validate_tpm_cert_chain, parse_cert_chain_pem, validate_cert_chain,
    validate_tpm_cert_chain, ChainValidationResult, MAX_CHAIN_DEPTH,
};

// Re-export time type for testing
pub use pki_types::UnixTime;

// Re-export types from vaportpm_attest for convenience
pub use vaportpm_attest::a9n::{
    AttestationContainer, AttestationData, AttestationOutput, EccPublicKeyCoords, EkCertificates,
    NitroAttestationData,
};

/// How the attestation was verified
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize)]
pub enum VerificationMethod {
    /// Verified via AWS Nitro attestation
    Nitro,
    /// Verified via cloud provider AK certificate chain (GCP/Azure)
    /// Note: Not yet implemented - reserved for future use
    #[allow(dead_code)]
    CloudAkChain,
}

/// Result of successful attestation verification
#[derive(Debug, Serialize)]
pub struct VerificationResult {
    /// The nonce that was verified (hex-encoded)
    pub nonce: String,
    /// SHA-256 hash of the root CA's public key
    pub root_pubkey_hash: String,
    /// How the attestation was verified
    pub method: VerificationMethod,
}

/// Verify an entire AttestationOutput
///
/// Currently supports one verification path:
///
/// 1. **Nitro path** (AWS): If Nitro attestation is present, verify it and trust
///    the TPM signing key via the Nitro document's `public_key` binding. The
///    TPM2B_ATTEST structure is verified for PCR policy binding. EK certificates
///    are not required in this path.
///
/// Future paths (not yet implemented):
/// - **GCP Shielded VM**: AK certificate from Google CA (NV index 0x01c10000)
/// - **Azure Trusted Launch**: AK certificate from Microsoft CA (NV index 0x01C101D0)
///
/// # Arguments
/// * `output` - The attestation output to verify
/// * `time` - Time to use for certificate validation (use `UnixTime::now()` for production)
///
/// # Returns
/// A unified `VerificationResult` containing:
/// - `nonce`: The verified challenge (from TPM2B_ATTEST.extraData)
/// - `root_pubkey_hash`: SHA-256 of the trust anchor's public key
/// - `method`: How verification was performed
///
/// # Errors
/// Returns `NoValidAttestation` if no supported verification path is available.
pub fn verify_attestation_output(
    output: &AttestationOutput,
    time: UnixTime,
) -> Result<VerificationResult, VerifyError> {
    // Must have at least one TPM attestation
    if output.attestation.tpm.is_empty() {
        return Err(VerifyError::NoValidAttestation(
            "no TPM attestations present".into(),
        ));
    }

    // Get the first (and typically only) TPM attestation
    let (key_type, attestation) = output.attestation.tpm.iter().next().unwrap();

    // Get the corresponding signing key (AK) public key
    let ak_pk = output
        .signing_key_public_keys
        .get(key_type)
        .ok_or_else(|| {
            VerifyError::NoValidAttestation(format!("{}: missing AK public key", key_type))
        })?;

    // Decode AK public key
    let ak_x = hex::decode(&ak_pk.x)?;
    let ak_y = hex::decode(&ak_pk.y)?;

    // Determine PCR algorithm based on verification path
    // Nitro uses SHA-384 (signed in Nitro document), non-Nitro uses SHA-256
    let (pcr_alg, pcrs_for_policy) = if output.attestation.nitro.is_some() {
        (
            TpmAlg::Sha384,
            output.pcrs.get("sha384").cloned().unwrap_or_default(),
        )
    } else {
        (
            TpmAlg::Sha256,
            output.pcrs.get("sha256").cloned().unwrap_or_default(),
        )
    };

    // Parse TPM2B_ATTEST structure (needed for both paths)
    let attest_data = hex::decode(&attestation.attest_data)?;
    let attest_info = parse_tpm2b_attest(&attest_data)?;

    // Verify nonce field matches nonce in attest_data (prevents tampering)
    let nonce_from_field = hex::decode(&attestation.nonce)?;
    if nonce_from_field != attest_info.nonce {
        return Err(VerifyError::InvalidAttest(format!(
            "Nonce field does not match nonce in attest_data. \
             Field: {}, Attest: {}",
            attestation.nonce,
            hex::encode(&attest_info.nonce)
        )));
    }

    // Verify AK signature over TPM2B_ATTEST
    let signature = hex::decode(&attestation.signature)?;
    let mut ak_pubkey = vec![0x04];
    ak_pubkey.extend(&ak_x);
    ak_pubkey.extend(&ak_y);
    verify_ecdsa_p256(&attest_data, &signature, &ak_pubkey)?;

    // Compute authPolicy from PCRs and verify certified name (proves PCR binding)
    if !pcrs_for_policy.is_empty() {
        let auth_policy_hex = calculate_pcr_policy(&pcrs_for_policy, pcr_alg)?;
        let auth_policy = hex::decode(&auth_policy_hex)?;

        let expected_name = compute_ecc_p256_name(&ak_x, &ak_y, &auth_policy);
        if attest_info.certified_name != expected_name {
            return Err(VerifyError::InvalidAttest(format!(
                "Certified key name does not match expected PCR policy. \
                 AK's authPolicy does not match claimed PCR values. \
                 Expected name: {}, Got: {}",
                hex::encode(&expected_name),
                hex::encode(&attest_info.certified_name)
            )));
        }
    }

    // If Nitro attestation is present, use Nitro path
    if let Some(ref nitro) = output.attestation.nitro {
        // Verify Nitro attestation (COSE signature, cert chain)
        let nitro_result = verify_nitro_attestation(
            &nitro.document,
            None, // Nonce validation happens via TPM binding
            None, // Pubkey validation happens below
            time,
        )?;

        // Verify the convenience fields match what's signed in the Nitro document.
        // These fields are duplicated in the JSON for easy access, but we must ensure
        // they match the cryptographically signed values to prevent tampering.

        // Verify public_key field matches signed document
        let signed_pubkey = nitro_result.document.public_key.as_ref().ok_or_else(|| {
            VerifyError::NoValidAttestation(
                "Nitro document missing public_key field - cannot bind TPM signing key".into(),
            )
        })?;
        if nitro.public_key != *signed_pubkey {
            return Err(VerifyError::SignatureInvalid(format!(
                "attestation.nitro.public_key does not match signed value in document: {} != {}",
                nitro.public_key, signed_pubkey
            )));
        }

        // Verify nonce field matches signed document
        let signed_nonce = nitro_result.document.nonce.as_ref().ok_or_else(|| {
            VerifyError::NoValidAttestation(
                "Nitro document missing nonce field - cannot verify freshness".into(),
            )
        })?;
        if nitro.nonce != *signed_nonce {
            return Err(VerifyError::SignatureInvalid(format!(
                "attestation.nitro.nonce does not match signed value in document: {} != {}",
                nitro.nonce, signed_nonce
            )));
        }

        // Verify the AK public key matches the signed public_key
        let ak_secg = format!("04{}{}", ak_pk.x, ak_pk.y);
        if ak_secg != *signed_pubkey {
            return Err(VerifyError::SignatureInvalid(format!(
                "TPM signing key does not match Nitro public_key binding: {} != {}",
                ak_secg, signed_pubkey
            )));
        }

        // Verify TPM nonce matches Nitro nonce (proves attestations generated together)
        let tpm_nonce_hex = hex::encode(&attest_info.nonce);
        if tpm_nonce_hex != *signed_nonce {
            return Err(VerifyError::SignatureInvalid(format!(
                "TPM nonce does not match Nitro nonce - attestations not generated together: {} != {}",
                tpm_nonce_hex, signed_nonce
            )));
        }

        // Verify SHA-384 PCRs match signed values in Nitro document
        // The Nitro document contains nitrotpm_pcrs which are signed by AWS hardware
        if let Some(sha384_pcrs) = output.pcrs.get("sha384") {
            let signed_pcrs = &nitro_result.document.pcrs;

            // Check all signed PCRs are present and match
            for (idx, signed_value) in signed_pcrs.iter() {
                match sha384_pcrs.get(idx) {
                    Some(claimed_value) if claimed_value == signed_value => {
                        // Match - good
                    }
                    Some(claimed_value) => {
                        return Err(VerifyError::SignatureInvalid(format!(
                            "PCR {} SHA-384 value does not match signed value: {} != {}",
                            idx, claimed_value, signed_value
                        )));
                    }
                    None => {
                        return Err(VerifyError::SignatureInvalid(format!(
                            "PCR {} missing from output.pcrs[sha384] but present in signed Nitro document",
                            idx
                        )));
                    }
                }
            }
        }

        // Nonce is from TPM2B_ATTEST.extraData
        return Ok(VerificationResult {
            nonce: hex::encode(&attest_info.nonce),
            root_pubkey_hash: nitro_result.root_pubkey_hash,
            method: VerificationMethod::Nitro,
        });
    }

    // No Nitro attestation - currently unsupported
    //
    // Future: GCP/Azure AK certificate path will be implemented here.
    // This requires:
    // 1. AK certificate from cloud provider (not just EK certificate)
    // 2. Certificate chain validation to cloud provider root CA
    // 3. AK certificate proves the signing key belongs to the cloud provider's vTPM
    //
    // EK certificates alone are NOT sufficient because:
    // - EK certificate only proves "this is a genuine TPM"
    // - It doesn't prove the AK (signing key) belongs to that TPM
    // - Without AK binding, an attacker could use their own signing key

    Err(VerifyError::NoValidAttestation(
        "No Nitro attestation present. \
         GCP/Azure AK certificate verification not yet implemented. \
         Currently only AWS Nitro attestation is supported."
            .into(),
    ))
}

/// Convenience function to verify attestation from JSON string
///
/// Parses JSON and calls `verify_attestation_output` with current time.
/// For testing with fixtures that have expired certificates, use
/// `verify_attestation_output` directly with a specific time.
pub fn verify_attestation_json(json: &str) -> Result<VerificationResult, VerifyError> {
    let output: AttestationOutput = serde_json::from_str(json)
        .map_err(|e| VerifyError::InvalidAttest(format!("JSON parse error: {}", e)))?;
    verify_attestation_output(&output, UnixTime::now())
}

#[cfg(test)]
mod tests {
    use super::*;

    // Timestamp from the test fixture (when the Nitro certificates were valid)
    // The nonce "31373639393233313833" decodes to "1769923183" which is a Unix timestamp
    const FIXTURE_TIMESTAMP_SECS: u64 = 1769923183;

    fn fixture_time() -> UnixTime {
        UnixTime::since_unix_epoch(std::time::Duration::from_secs(FIXTURE_TIMESTAMP_SECS))
    }

    #[test]
    fn test_verify_nitro_fixture() {
        let fixture = include_str!("../test-nitro-fixture.json");
        let output: AttestationOutput =
            serde_json::from_str(fixture).expect("Failed to parse test-nitro-fixture.json");

        let result = verify_attestation_output(&output, fixture_time())
            .expect("Verification should succeed");

        // Should be verified via Nitro path (no EK certs in fixture)
        assert_eq!(result.method, VerificationMethod::Nitro);

        // Nonce is now from TPM2B_ATTEST.extraData, not the raw attest_data field
        assert!(!result.nonce.is_empty());

        // Should have a root pubkey hash (AWS Nitro root)
        assert!(!result.root_pubkey_hash.is_empty());
        assert_eq!(result.root_pubkey_hash.len(), 64); // SHA-256 = 32 bytes = 64 hex chars
    }

    #[test]
    fn test_reject_empty_attestation() {
        let output = AttestationOutput {
            ek_certificates: EkCertificates {
                rsa_2048: None,
                ecc_p256: None,
                ecc_p384: None,
            },
            pcrs: std::collections::HashMap::new(),
            ek_public_keys: std::collections::HashMap::new(),
            signing_key_public_keys: std::collections::HashMap::new(),
            attestation: AttestationContainer {
                tpm: std::collections::HashMap::new(),
                nitro: None,
            },
        };

        let result = verify_attestation_output(&output, UnixTime::now());
        assert!(matches!(result, Err(VerifyError::NoValidAttestation(_))));
    }

    /// Test that tampering with the convenience public_key field is detected
    #[test]
    fn test_reject_tampered_nitro_public_key() {
        let fixture = include_str!("../test-nitro-fixture.json");
        let mut output: AttestationOutput =
            serde_json::from_str(fixture).expect("Failed to parse test-nitro-fixture.json");

        // Tamper with the convenience field (attacker tries to substitute their own key)
        if let Some(ref mut nitro) = output.attestation.nitro {
            nitro.public_key = "04aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb".to_string();
        }

        let result = verify_attestation_output(&output, fixture_time());
        assert!(
            matches!(result, Err(VerifyError::SignatureInvalid(_))),
            "Should reject tampered public_key field, got: {:?}",
            result
        );
    }

    /// Test that tampering with the convenience nonce field is detected
    #[test]
    fn test_reject_tampered_nitro_nonce() {
        let fixture = include_str!("../test-nitro-fixture.json");
        let mut output: AttestationOutput =
            serde_json::from_str(fixture).expect("Failed to parse test-nitro-fixture.json");

        // Tamper with the convenience field
        if let Some(ref mut nitro) = output.attestation.nitro {
            nitro.nonce = "deadbeef".to_string();
        }

        let result = verify_attestation_output(&output, fixture_time());
        assert!(
            matches!(result, Err(VerifyError::SignatureInvalid(_))),
            "Should reject tampered nonce field, got: {:?}",
            result
        );
    }

    /// Test that tampering with SHA-384 PCR values is detected
    #[test]
    fn test_reject_tampered_pcr_values() {
        let fixture = include_str!("../test-nitro-fixture.json");
        let mut output: AttestationOutput =
            serde_json::from_str(fixture).expect("Failed to parse test-nitro-fixture.json");

        // Tamper with a SHA-384 PCR value
        if let Some(sha384_pcrs) = output.pcrs.get_mut("sha384") {
            sha384_pcrs.insert(
                0,
                "deadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef".to_string()
            );
        }

        let result = verify_attestation_output(&output, fixture_time());
        // Tampering is detected at policy verification: AK's authPolicy doesn't match PCR values
        assert!(
            matches!(result, Err(VerifyError::InvalidAttest(_))),
            "Should reject tampered PCR values, got: {:?}",
            result
        );
    }
}
