// SPDX-License-Identifier: MIT OR Apache-2.0

//! Attestation verification for TPM and Nitro attestations
//!
//! This crate provides verification of attestation documents generated by vaportpm_attest:
//! - TPM attestation verification with EK public key matching
//! - X.509 certificate chain validation
//! - AWS Nitro COSE Sign1 document verification
//! - GCP Shielded VM AK certificate verification
//! - Root certificate public key hash extraction (SHA-256, hex-encoded)

mod error;
mod gcp;
mod nitro;
mod tpm;
mod x509;

use std::collections::BTreeMap;

use serde::{Deserialize, Serialize};
use serde_big_array::BigArray;

// Re-export error type
pub use error::VerifyError;

// Re-export TPM types and functions (only those used by verification paths)
pub use tpm::{parse_quote_attest, verify_ecdsa_p256, verify_pcr_digest_matches, TpmQuoteInfo};

// Re-export from vaportpm_attest
pub use vaportpm_attest::TpmAlg;

// Re-export X.509 utility functions
pub use x509::{
    extract_public_key, hash_public_key, parse_and_validate_tpm_cert_chain, parse_cert_chain_pem,
    validate_tpm_cert_chain, ChainValidationResult, MAX_CHAIN_DEPTH,
};

// Re-export time type for testing
pub use pki_types::UnixTime;

/// Cloud provider identification
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize)]
pub enum CloudProvider {
    /// Amazon Web Services (Nitro TPM)
    Aws,
    /// Google Cloud Platform (Shielded VM)
    Gcp,
}

/// Known root CA certificates and public key hashes for cloud providers
///
/// Hashes are pre-computed constants to avoid PEM parsing in zkVM guests.
pub mod roots {
    use super::CloudProvider;

    // Re-export embedded root certificate PEMs from vaportpm_attest
    pub use vaportpm_attest::roots::{AWS_NITRO_ROOT_PEM, GCP_EKAK_ROOT_PEM};

    // Re-export SKI/AKI lookup
    pub use vaportpm_attest::roots::find_issuer_by_aki;

    /// AWS Nitro Enclave Root CA public key hash (SHA-256, pre-computed)
    pub const AWS_NITRO_ROOT_HASH: [u8; 32] = [
        0xfb, 0x70, 0x59, 0x38, 0x0c, 0x01, 0xce, 0x83, 0x78, 0x53, 0x58, 0x08, 0x97, 0x1f, 0x48,
        0xad, 0xb2, 0x61, 0x1f, 0x2d, 0x33, 0x2c, 0x9e, 0x18, 0xbb, 0xfa, 0x1b, 0x84, 0xcf, 0x7c,
        0xad, 0xe2,
    ];

    /// GCP Shielded VM EK/AK Root CA public key hash (SHA-256, pre-computed)
    pub const GCP_EKAK_ROOT_HASH: [u8; 32] = [
        0x9a, 0xb8, 0x45, 0xee, 0x46, 0x63, 0x63, 0x8e, 0x86, 0x81, 0x29, 0xc7, 0xe8, 0xdd, 0x4b,
        0x2a, 0x63, 0xa5, 0x12, 0x3f, 0xd8, 0x5d, 0x7b, 0x60, 0x28, 0x15, 0xa7, 0xc6, 0xc4, 0xad,
        0xe7, 0x69,
    ];

    /// Look up cloud provider from root public key hash
    #[inline]
    pub fn provider_from_hash(hash: &[u8; 32]) -> Option<CloudProvider> {
        if hash == &AWS_NITRO_ROOT_HASH {
            Some(CloudProvider::Aws)
        } else if hash == &GCP_EKAK_ROOT_HASH {
            Some(CloudProvider::Gcp)
        } else {
            None
        }
    }
}

// Re-export types from vaportpm_attest for convenience
pub use vaportpm_attest::a9n::{
    AttestationContainer, AttestationData, AttestationOutput, EccPublicKeyCoords,
    GcpAttestationData, NitroAttestationData,
};

/// Binary attestation data - all fields already decoded from hex/PEM
///
/// This struct holds pre-decoded attestation data for efficient verification
/// in constrained environments (e.g., zkVM guests) where text parsing is expensive.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DecodedAttestationOutput {
    /// Nonce (32 bytes, already decoded from hex)
    pub nonce: [u8; 32],

    /// PCR values: (algorithm_id, pcr_index) â†’ value
    /// Algorithm IDs: 0 = SHA-256, 1 = SHA-384
    pub pcrs: BTreeMap<(u8, u8), Vec<u8>>,

    /// AK public key (65 bytes SEC1 uncompressed: 0x04 || x || y)
    #[serde(with = "BigArray")]
    pub ak_pubkey: [u8; 65],

    /// TPM Quote attest_data (raw bytes)
    pub quote_attest: Vec<u8>,

    /// TPM Quote signature (raw DER bytes)
    pub quote_signature: Vec<u8>,

    /// Platform-specific attestation
    pub platform: DecodedPlatformAttestation,
}

/// Platform-specific attestation data in decoded binary format
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DecodedPlatformAttestation {
    /// GCP: certificate chain as DER bytes (leaf first)
    Gcp { cert_chain_der: Vec<Vec<u8>> },

    /// Nitro: COSE document (raw bytes, already hex-decoded)
    Nitro { document: Vec<u8> },
}

pub mod flat;

impl DecodedAttestationOutput {
    /// Decode an AttestationOutput to binary format
    pub fn decode(output: &AttestationOutput) -> Result<Self, VerifyError> {
        use der::Encode;

        let nonce_bytes = hex::decode(&output.nonce)?;
        let nonce: [u8; 32] = nonce_bytes
            .try_into()
            .map_err(|_| VerifyError::InvalidAttest("nonce must be 32 bytes".into()))?;

        let ak_pk = output.ak_pubkeys.get("ecc_p256").ok_or_else(|| {
            VerifyError::NoValidAttestation("missing ecc_p256 AK public key".into())
        })?;
        let ak_x = hex::decode(&ak_pk.x)?;
        let ak_y = hex::decode(&ak_pk.y)?;
        let mut ak_pubkey = [0u8; 65];
        ak_pubkey[0] = 0x04;
        ak_pubkey[1..33].copy_from_slice(&ak_x);
        ak_pubkey[33..65].copy_from_slice(&ak_y);

        let tpm = output.attestation.tpm.get("ecc_p256").ok_or_else(|| {
            VerifyError::NoValidAttestation("missing ecc_p256 TPM attestation".into())
        })?;
        let quote_attest = hex::decode(&tpm.attest_data)?;
        let quote_signature = hex::decode(&tpm.signature)?;

        let mut pcrs = BTreeMap::new();
        for (alg_name, pcr_map) in &output.pcrs {
            let alg_id = match alg_name.as_str() {
                "sha256" => 0u8,
                "sha384" => 1u8,
                _ => continue,
            };
            for (idx, hex_value) in pcr_map {
                let value = hex::decode(hex_value)?;
                pcrs.insert((alg_id, *idx), value);
            }
        }

        let platform = if let Some(ref gcp) = output.attestation.gcp {
            let certs = parse_cert_chain_pem(&gcp.ak_cert_chain)?;
            let cert_chain_der: Vec<Vec<u8>> = certs
                .iter()
                .map(|c| c.to_der())
                .collect::<Result<_, _>>()
                .map_err(|e| {
                    VerifyError::CertificateParse(format!("Failed to encode cert as DER: {}", e))
                })?;
            DecodedPlatformAttestation::Gcp { cert_chain_der }
        } else if let Some(ref nitro) = output.attestation.nitro {
            let document = hex::decode(&nitro.document)?;
            DecodedPlatformAttestation::Nitro { document }
        } else {
            return Err(VerifyError::NoValidAttestation(
                "no platform attestation".into(),
            ));
        };

        Ok(DecodedAttestationOutput {
            nonce,
            pcrs,
            ak_pubkey,
            quote_attest,
            quote_signature,
            platform,
        })
    }
}

/// Verify pre-decoded attestation (for zkVM)
/// Verify pre-decoded attestation
///
/// # Arguments
/// * `decoded` - Pre-decoded attestation data
/// * `time` - Verification timestamp for certificate validation
pub fn verify_decoded_attestation_output(
    decoded: &DecodedAttestationOutput,
    time: UnixTime,
) -> Result<VerificationResult, VerifyError> {
    match &decoded.platform {
        DecodedPlatformAttestation::Gcp { cert_chain_der } => {
            gcp::verify_gcp_decoded(decoded, cert_chain_der, time)
        }
        DecodedPlatformAttestation::Nitro { document } => {
            nitro::verify_nitro_decoded(decoded, document, time)
        }
    }
}

/// Result of successful attestation verification
#[derive(Debug, Serialize)]
pub struct VerificationResult {
    /// The nonce that was verified (32 bytes)
    pub nonce: [u8; 32],
    /// Cloud provider that issued the attestation
    pub provider: CloudProvider,
    /// PCR values from the attestation: (algorithm_id, pcr_index) -> raw digest bytes
    /// Algorithm IDs: 0 = SHA-256, 1 = SHA-384
    pub pcrs: BTreeMap<(u8, u8), Vec<u8>>,
    /// Timestamp when verification was performed (seconds since Unix epoch)
    pub verified_at: u64,
}

/// Verify an entire AttestationOutput
///
/// Supports two verification paths, both using TPM2_Quote:
///
/// 1. **GCP path**: If GCP attestation is present, verify the AK certificate
///    chain to Google's root CA, then verify the TPM2_Quote signature. PCR
///    values are verified against the Quote's PCR digest.
///
/// 2. **Nitro path** (AWS): If Nitro attestation is present, verify it and trust
///    the TPM signing key via the Nitro document's `public_key` binding. The
///    TPM2_Quote is verified for PCR values.
///
/// # Arguments
/// * `output` - The attestation output to verify
/// * `time` - Time to use for certificate validation (use `UnixTime::now()` for production)
///
/// # Returns
/// A unified `VerificationResult` containing:
/// - `nonce`: The verified challenge (from TPM2_Quote.extraData)
/// - `provider`: Cloud provider (AWS/GCP) if root CA is recognized
/// - `pcrs`: PCR values from the attestation
/// - `root_pubkey_hash`: SHA-256 of the trust anchor's public key
///
/// # Errors
/// Returns `NoValidAttestation` if no supported verification path is available.
pub fn verify_attestation_output(
    output: &AttestationOutput,
    time: UnixTime,
) -> Result<VerificationResult, VerifyError> {
    // Decode to binary format (all hex/PEM parsing happens here)
    let decoded = DecodedAttestationOutput::decode(output)?;

    // Delegate to single verification path
    verify_decoded_attestation_output(&decoded, time)
}

/// Convenience function to verify attestation from JSON string
///
/// Parses JSON and calls `verify_attestation_output` with current time.
/// For testing with fixtures that have expired certificates, use
/// `verify_attestation_output` directly with a specific time.
pub fn verify_attestation_json(json: &str) -> Result<VerificationResult, VerifyError> {
    let output: AttestationOutput = serde_json::from_str(json)
        .map_err(|e| VerifyError::InvalidAttest(format!("JSON parse error: {}", e)))?;
    verify_attestation_output(&output, UnixTime::now())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_reject_empty_attestation() {
        let output = AttestationOutput {
            nonce: "0000000000000000000000000000000000000000000000000000000000000000".to_string(),
            pcrs: std::collections::HashMap::new(),
            ak_pubkeys: std::collections::HashMap::new(),
            attestation: AttestationContainer {
                tpm: std::collections::HashMap::new(),
                nitro: None,
                gcp: None,
            },
        };

        // With the new architecture, decode() fails first when there's no AK pubkey
        let result = verify_attestation_output(&output, UnixTime::now());
        assert!(
            result.is_err(),
            "Should reject attestation with missing components"
        );
    }
}
