// SPDX-License-Identifier: MIT OR Apache-2.0

//! Attestation verification for TPM and Nitro attestations
//!
//! This crate provides verification of attestation documents generated by vaportpm_attest:
//! - TPM attestation verification with EK public key matching
//! - X.509 certificate chain validation
//! - AWS Nitro COSE Sign1 document verification
//! - GCP Shielded VM AK certificate verification
//! - Root certificate public key hash extraction (SHA-256, hex-encoded)

mod error;
mod gcp;
mod nitro;
pub mod pcr;
mod tpm;
mod x509;

use serde::Serialize;
use x509::parse_cert_chain_pem;

// Re-export error types
pub use error::{
    CborParseReason, CertificateParseReason, ChainValidationReason, CoseVerifyReason,
    InvalidAttestReason, NoValidAttestationReason, PcrIndexOutOfBoundsReason,
    SignatureInvalidReason, VerifyError,
};

// Re-export PCR types
pub use pcr::{P256PublicKey, PcrAlgorithm, PcrBank, PCR_COUNT};

// Re-export time type for testing
pub use pki_types::UnixTime;

/// Cloud provider identification
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize)]
pub enum CloudProvider {
    /// Amazon Web Services (Nitro TPM)
    Aws,
    /// Google Cloud Platform (Shielded VM)
    Gcp,
}

/// Known root CA certificates and public key hashes for cloud providers
///
/// Hashes are pre-computed constants to avoid PEM parsing in zkVM guests.
pub mod roots {
    use super::CloudProvider;

    // Re-export embedded root certificate PEMs from vaportpm_attest
    pub use vaportpm_attest::roots::{AWS_NITRO_ROOT_PEM, GCP_EKAK_ROOT_PEM};

    // Re-export SKI/AKI lookup
    pub use vaportpm_attest::roots::find_issuer_by_aki;

    /// AWS Nitro Enclave Root CA public key hash (SHA-256, pre-computed)
    pub const AWS_NITRO_ROOT_HASH: [u8; 32] = [
        0xfb, 0x70, 0x59, 0x38, 0x0c, 0x01, 0xce, 0x83, 0x78, 0x53, 0x58, 0x08, 0x97, 0x1f, 0x48,
        0xad, 0xb2, 0x61, 0x1f, 0x2d, 0x33, 0x2c, 0x9e, 0x18, 0xbb, 0xfa, 0x1b, 0x84, 0xcf, 0x7c,
        0xad, 0xe2,
    ];

    /// GCP Shielded VM EK/AK Root CA public key hash (SHA-256, pre-computed)
    pub const GCP_EKAK_ROOT_HASH: [u8; 32] = [
        0x9a, 0xb8, 0x45, 0xee, 0x46, 0x63, 0x63, 0x8e, 0x86, 0x81, 0x29, 0xc7, 0xe8, 0xdd, 0x4b,
        0x2a, 0x63, 0xa5, 0x12, 0x3f, 0xd8, 0x5d, 0x7b, 0x60, 0x28, 0x15, 0xa7, 0xc6, 0xc4, 0xad,
        0xe7, 0x69,
    ];

    /// Look up cloud provider from root public key hash
    #[inline]
    pub fn provider_from_hash(hash: &[u8; 32]) -> Option<CloudProvider> {
        if hash == &AWS_NITRO_ROOT_HASH {
            Some(CloudProvider::Aws)
        } else if hash == &GCP_EKAK_ROOT_HASH {
            Some(CloudProvider::Gcp)
        } else {
            #[cfg(test)]
            {
                if let Some(provider) = test_registry::lookup_test_root(hash) {
                    return Some(provider);
                }
            }
            None
        }
    }

    #[cfg(test)]
    pub use test_registry::{register_test_root, TestRootGuard};

    #[cfg(test)]
    mod test_registry {
        use super::CloudProvider;
        use std::cell::RefCell;
        use std::collections::HashMap;

        thread_local! {
            static TEST_ROOTS: RefCell<HashMap<[u8; 32], CloudProvider>> =
                RefCell::new(HashMap::new());
        }

        /// RAII guard that removes a test root on drop (even on panic).
        pub struct TestRootGuard {
            hash: [u8; 32],
        }

        impl Drop for TestRootGuard {
            fn drop(&mut self) {
                TEST_ROOTS.with(|roots| {
                    roots.borrow_mut().remove(&self.hash);
                });
            }
        }

        /// Register an ephemeral root CA hash for testing.
        /// Returns an RAII guard that removes the entry on drop.
        pub fn register_test_root(hash: [u8; 32], provider: CloudProvider) -> TestRootGuard {
            TEST_ROOTS.with(|roots| {
                roots.borrow_mut().insert(hash, provider);
            });
            TestRootGuard { hash }
        }

        /// Look up a test root by hash (called from `provider_from_hash`).
        pub fn lookup_test_root(hash: &[u8; 32]) -> Option<CloudProvider> {
            TEST_ROOTS.with(|roots| roots.borrow().get(hash).copied())
        }
    }
}

// Re-export types from vaportpm_attest for convenience
pub use vaportpm_attest::a9n::{
    AttestationContainer, AttestationData, AttestationOutput, EccPublicKeyCoords,
    GcpAttestationData, NitroAttestationData,
};

/// Binary attestation data - all fields already decoded from hex/PEM
///
/// This struct holds pre-decoded attestation data for efficient verification
/// in constrained environments (e.g., zkVM guests) where text parsing is expensive.
#[derive(Debug, Clone)]
pub struct DecodedAttestationOutput {
    /// Nonce (32 bytes, already decoded from hex)
    pub nonce: [u8; 32],

    /// Validated PCR bank (single algorithm, exactly 24 values)
    pub pcrs: PcrBank,

    /// AK public key (P-256)
    pub ak_pubkey: P256PublicKey,

    /// TPM Quote attest_data (raw bytes)
    pub quote_attest: Vec<u8>,

    /// TPM Quote signature (raw DER bytes)
    pub quote_signature: Vec<u8>,

    /// Platform-specific attestation
    pub platform: DecodedPlatformAttestation,
}

/// Platform-specific attestation data in decoded binary format
#[derive(Debug, Clone)]
pub enum DecodedPlatformAttestation {
    /// GCP: certificate chain as DER bytes (leaf first)
    Gcp { cert_chain_der: Vec<Vec<u8>> },

    /// Nitro: COSE document (raw bytes, already hex-decoded)
    Nitro { document: Vec<u8> },
}

pub mod flat;

#[cfg(test)]
mod test_support;

impl DecodedAttestationOutput {
    /// Decode an AttestationOutput to binary format
    pub fn decode(output: &AttestationOutput) -> Result<Self, VerifyError> {
        use der::Encode;

        let nonce_bytes = hex::decode(&output.nonce)?;
        let nonce: [u8; 32] = nonce_bytes
            .try_into()
            .map_err(|_| InvalidAttestReason::NonceLengthInvalid)?;

        let ak_pk = output
            .ak_pubkeys
            .get("ecc_p256")
            .ok_or(NoValidAttestationReason::MissingAkPublicKey)?;
        let ak_x = hex::decode(&ak_pk.x)?;
        let ak_y = hex::decode(&ak_pk.y)?;
        let ak_pubkey = P256PublicKey::from_coords(&ak_x, &ak_y)?;

        let tpm = output
            .attestation
            .tpm
            .get("ecc_p256")
            .ok_or(NoValidAttestationReason::MissingTpmAttestation)?;
        let quote_attest = hex::decode(&tpm.attest_data)?;
        let quote_signature = hex::decode(&tpm.signature)?;

        let mut pcr_entries = Vec::new();
        let mut algorithm = None;
        for (alg_name, pcr_map) in &output.pcrs {
            let alg = match alg_name.as_str() {
                "sha256" => PcrAlgorithm::Sha256,
                "sha384" => PcrAlgorithm::Sha384,
                _ => continue,
            };
            if algorithm.is_some() && algorithm != Some(alg) {
                return Err(InvalidAttestReason::PcrBankMixedAlgorithms.into());
            }
            algorithm = Some(alg);
            for (idx, hex_value) in pcr_map {
                pcr_entries.push((*idx, hex::decode(hex_value)?));
            }
        }
        let algorithm = algorithm.ok_or(InvalidAttestReason::PcrBankEmpty)?;
        let pcrs = PcrBank::from_values(algorithm, pcr_entries)?;

        let platform = if let Some(ref gcp) = output.attestation.gcp {
            let certs = parse_cert_chain_pem(&gcp.ak_cert_chain)?;
            let cert_chain_der: Vec<Vec<u8>> = certs
                .iter()
                .map(|c| c.to_der())
                .collect::<Result<_, _>>()
                .map_err(|e| CertificateParseReason::DerEncodeFailed(e.to_string()))?;
            DecodedPlatformAttestation::Gcp { cert_chain_der }
        } else if let Some(ref nitro) = output.attestation.nitro {
            let document = hex::decode(&nitro.document)?;
            DecodedPlatformAttestation::Nitro { document }
        } else {
            return Err(NoValidAttestationReason::NoPlatform.into());
        };

        Ok(DecodedAttestationOutput {
            nonce,
            pcrs,
            ak_pubkey,
            quote_attest,
            quote_signature,
            platform,
        })
    }
}

/// Verify pre-decoded attestation (for zkVM)
/// Verify pre-decoded attestation
///
/// # Arguments
/// * `decoded` - Pre-decoded attestation data
/// * `time` - Verification timestamp for certificate validation
pub fn verify_decoded_attestation_output(
    decoded: &DecodedAttestationOutput,
    time: UnixTime,
) -> Result<VerificationResult, VerifyError> {
    match &decoded.platform {
        DecodedPlatformAttestation::Gcp { cert_chain_der } => {
            gcp::verify_gcp_decoded(decoded, cert_chain_der, time)
        }
        DecodedPlatformAttestation::Nitro { document } => {
            nitro::verify_nitro_decoded(decoded, document, time)
        }
    }
}

/// Result of successful attestation verification
#[derive(Debug)]
pub struct VerificationResult {
    /// The nonce that was verified (32 bytes)
    pub nonce: [u8; 32],
    /// Cloud provider that issued the attestation
    pub provider: CloudProvider,
    /// Validated PCR bank from the attestation
    pub pcrs: PcrBank,
    /// Timestamp when verification was performed (seconds since Unix epoch)
    pub verified_at: u64,
}

/// Verify an entire AttestationOutput
///
/// Supports two verification paths, both using TPM2_Quote:
///
/// 1. **GCP path**: If GCP attestation is present, verify the AK certificate
///    chain to Google's root CA, then verify the TPM2_Quote signature. PCR
///    values are verified against the Quote's PCR digest.
///
/// 2. **Nitro path** (AWS): If Nitro attestation is present, verify it and trust
///    the TPM signing key via the Nitro document's `public_key` binding. The
///    TPM2_Quote is verified for PCR values.
///
/// # Arguments
/// * `output` - The attestation output to verify
/// * `time` - Time to use for certificate validation (use `UnixTime::now()` for production)
///
/// # Returns
/// A unified `VerificationResult` containing:
/// - `nonce`: The verified challenge (from TPM2_Quote.extraData)
/// - `provider`: Cloud provider (AWS/GCP) if root CA is recognized
/// - `pcrs`: PCR values from the attestation
/// - `root_pubkey_hash`: SHA-256 of the trust anchor's public key
///
/// # Errors
/// Returns `NoValidAttestation` if no supported verification path is available.
pub fn verify_attestation_output(
    output: &AttestationOutput,
    time: UnixTime,
) -> Result<VerificationResult, VerifyError> {
    // Decode to binary format (all hex/PEM parsing happens here)
    let decoded = DecodedAttestationOutput::decode(output)?;

    // Delegate to single verification path
    verify_decoded_attestation_output(&decoded, time)
}

/// Convenience function to verify attestation from JSON string
///
/// Parses JSON and calls `verify_attestation_output` with current time.
/// For testing with fixtures that have expired certificates, use
/// `verify_attestation_output` directly with a specific time.
pub fn verify_attestation_json(json: &str) -> Result<VerificationResult, VerifyError> {
    let output: AttestationOutput =
        serde_json::from_str(json).map_err(InvalidAttestReason::JsonParse)?;
    verify_attestation_output(&output, UnixTime::now())
}

#[cfg(test)]
mod ephemeral_gcp_tests;
#[cfg(test)]
mod ephemeral_nitro_tests;

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_reject_empty_attestation() {
        let output = AttestationOutput {
            nonce: "0000000000000000000000000000000000000000000000000000000000000000".to_string(),
            pcrs: std::collections::HashMap::new(),
            ak_pubkeys: std::collections::HashMap::new(),
            attestation: AttestationContainer {
                tpm: std::collections::HashMap::new(),
                nitro: None,
                gcp: None,
            },
        };

        // With the new architecture, decode() fails first when there's no AK pubkey
        let result = verify_attestation_output(&output, UnixTime::now());
        assert!(
            result.is_err(),
            "Should reject attestation with missing components"
        );
    }
}
